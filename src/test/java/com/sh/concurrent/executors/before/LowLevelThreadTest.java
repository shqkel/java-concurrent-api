package com.sh.concurrent.executors.before;

import org.junit.jupiter.api.DisplayName;
import org.junit.jupiter.api.Test;

/**
 * <h1>프로세스와 쓰레드</h1>
 * <pre>
 * 프로세스
 * - "실행 중인 프로그램" 을 프로세스라고 칭함
 * - OS로부터 실제 메모리를 할당 받아 실행 중인 상태
 * - 프로세스는 프로그램을 수행하는데 필요한 데이터와 메모리, 그리고 쓰레드로 구성 되어 있음
 * - 모든 프로세스에는 최소한 하나 이상의 쓰레드가 존재하며, 둘 이상의 쓰레드를 가진 프로세스를 멀티 쓰레드 프로세스(Multi-Threaded Process) 라고 함
 *
 * 쓰레드
 * - 프로세스가 일을 처리하는 최소 작업 단위
 * - 기본적으로 cpu는 실행 요청 순서에 따라 프로세스의 실행순서를 결정함
 *  - 작업 스케쥴링 이라고 하며 FIFO 구조로 되어 있음)
 * 	- FIFO : First Input First Output
 *
 * 싱글 쓰레드 프로세스
 * - 한번에 한 작업만 가능함
 *  - 채팅 프로그램에서 채팅 입력과 받은 데이터 출력은 동시에 될 수가 없음
 * - 하나의 쓰레드 밖에 없기 때문에 순차적인 작업을 해야 함
 *
 * 멀티 쓰레드 프로세스
 * - 한번에 여러 작업이 가능함
 *  - 채팅 프로그램에서 채팅 입력과 받은 데이터 출력을 별개의 작업으로 처리 할 수 있기 때문에 데이터를 받아서 처리하면서 입력도 동시에 가능해짐
 * - 멀티 쓰레드로 구성된 프로세스는 실행 내용을 쪼갠다고 보면 됨
 *  - 쪼갠 한 조각씩은 쓰레드 라고 보면 됨
 *  - 쪼갠 쓰레드는 요청 순서에 상관없이 실행됨(실제 스케쥴링은 OS(CPU)에 의존한다.)
 *
 * 멀티쓰레딩의 장점
 * - CPU 사용률을 향상시킴
 * - 자원을 보다 효율적으로 사용할 수 있음
 * - 사용자에 대한 응답성이 향상됨
 * - 작업이 분리되어 코드가 간결해짐
 *
 * 쓰레드를 쓰면 프로세스에 무조건 좋은가?
 * - 정답은 아니다 이다.
 * - 쓰레드를 잘 활용함으로써 프로세스가 원하는 형태로 작동 될 수 있지만 동기화 및 교착상태 같은 문제들을 해결하지 못한다면 예상치 못하는 문제점이 발생할 수 있게 된다.
 *
 * 동기화 (Synchronization)
 * - 쓰레드간 공유하는 자원에 대해서 작업순서를 지정하는 것.
 * - 동기화 한다는 것은 타이밍을 맞춘다는 것으로 현재 쓰레드의 작업완료와 다음쓰레드의 작업시작 타이밍을 맞춘다는 것이다.
 * - 내부적으로는 공유자원에 대한 Lock을 획득하고 반환하는 방식으로 이루어진다.
 *
 * 동기화관련 - 교착 상태 (Deadlock)
 * - 두 스레드가 여러개의 공유자원을 사용할때 발생할수 있다.
 * - A,B 공유자원을 사용하는 두 쓰레드가 자원을 하나씩 점유한 상태에서 서로 상대쓰래드가 점유한 자원을 사용하려고 기다리느라 진행이 멈춰있는 상태
 * - 임계지역을 A, B 공유자원을 모두 포함시키는 방식으로 해결할 수 있다.
 *
 * </pre>
 *
 * @author shqkel1863
 *
 */
public class LowLevelThreadTest {

    @DisplayName("쓰레드를 직접 제어하기")
    @Test
    public void test() {
        new Thread(() -> System.out.println(Thread.currentThread().getName())).start(); // Thread-0
        System.out.println(Thread.currentThread().getName()); // main (Test worker)
    }


}
